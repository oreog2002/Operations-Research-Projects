Code for the main CPLEX file used for Steelco Inc. Inventory Decision Model:
//----------------------------------------------------------------------
// Steelco Multi-Period Inventory Model
//----------------------------------------------------------------------

// ----- 1. SETS -----
// Define the sets for products, materials, and time.

setof(string) Products = ...;   // e.g., {"I", "W", "U", "H", "L"}
setof(string) Materials = ...;  // e.g., {"New", "Recycled"}

int numMonths = ...;          // e.g., 12
range Time = 1..numMonths;      // Time periods t = 1 to 12
range Time0 = 0..numMonths;     // Time periods t = 0 to 12 (for inventory)


// ----- 2. PARAMETERS (Data) -----
// These are the fixed values from your problem. They will be
// initialized from the .dat file.

float SP[Products] = ...;                // Selling Price
float DC[Products][Time] = ...;          // Demand
float MC[Materials] = ...;               // Material Cost
float IC = ...;                          // Inventory Cost
float PC[Products] = ...;                // Penalty (Backorder) Cost
float PL[Materials] = ...;               // Purchase Limit
float Yield[Materials] = ...;            // Material Yield
float QR[Products] = ...;                // Quality Requirement (min % of New)


// ----- 3. DECISION VARIABLES -----
// These are the unknown quantities the solver needs to find.
// "float+" means the variable must be >= 0.

dvar float+ buy[Materials][Time];           // Tons of material j purchased in month t
dvar float+ steel[Products][Materials][Time]; // Tons of product i from material j in month t
dvar float+ inv[Products][Time0];           // Tons of product i in inventory at END of month t
dvar float+ back[Products][Time0];          // Tons of product i on backorder at END of month t


// ----- 4. OBJECTIVE FUNCTION -----
// The goal: Maximize total profit.
// Profit = Revenue - Material Cost - Inventory Cost - Backorder Cost

maximize
  // Total Revenue
  sum(t in Time, i in Products, j in Materials) 
    (SP[i] * steel[i,j,t])
    
  // Total Material Cost
  - sum(t in Time, j in Materials) 
    (MC[j] * buy[j,t])
    
  // Total Inventory Cost
  - sum(t in Time, i in Products) 
    (IC * inv[i,t])
    
  // Total Backorder Cost
  - sum(t in Time, i in Products) 
    (PC[i] * back[i,t]);


// ----- 5. CONSTRAINTS -----
// The rules of the problem.

subject to {

  // 1. Material Purchase Limit:
  // Cannot buy more than the monthly limit for each material.
  forall(j in Materials, t in Time)
    ct_PurchaseLimit:
      buy[j,t] <= PL[j];

  // 2. Material Usage:
  // Total production from a material cannot exceed the usable amount purchased.
  forall(j in Materials, t in Time)
    ct_MaterialUsage:
      sum(i in Products) steel[i,j,t] <= Yield[j] * buy[j,t];

  // 3. Quality Requirement:
  // Production from 'New' steel must meet the minimum quality percentage.
  forall(i in Products, t in Time)
    ct_QualityReq:
      steel[i,"New",t] >= QR[i] * (sum(j in Materials) steel[i,j,t]);

  // 4. Inventory Balance:
  // This is the main flow constraint that links all time periods.
  // NetInventory(t) = NetInventory(t-1) + Production(t) - Demand(t)
  forall(i in Products, t in Time)
    ct_InventoryBalance:
      (inv[i,t] - back[i,t]) == (inv[i,t-1] - back[i,t-1]) 
                               + (sum(j in Materials) steel[i,j,t]) 
                               - DC[i,t];

  // 5. Initial and Final Conditions:
  // Must start and end the year with zero inventory and zero backorders.
  
  // Initial (t=0)
  forall(i in Products) {
    ct_InitialInv:  inv[i,0] == 0;
    ct_InitialBack: back[i,0] == 0;
  }
  
  // Final (t=12)
  forall(i in Products) {
    ct_FinalInv:  inv[i,numMonths] == 0;
    ct_FinalBack: back[i,numMonths] == 0;
  }
}

// 6. POST-PROCESSING (Results)
//----------------------------------------------------------------------
execute {
  // --- 1. Display the Main Objective (Total Profit) ---
  writeln("----------------------------------------------------------");
  writeln("          *** STEELCO OPTIMIZATION RESULTS ***");
  writeln("----------------------------------------------------------");
  writeln("Total Profit for 2025: $", cplex.getObjValue());
  writeln();

  // --- 2. Calculate and Display Profit Components ---
  // It's useful to see the individual components of the profit calculation.
  
  var totalRevenue = 0;
  for(var t in Time) {
    for(var i in Products) {
      for(var j in Materials) {
        totalRevenue += SP[i] * steel[i][j][t].solutionValue;
      }
    }
  }
  writeln("  Total Revenue:   $", totalRevenue);

  var totalMaterialCost = 0;
  for(var t in Time) {
    for(var j in Materials) {
      totalMaterialCost += MC[j] * buy[j][t].solutionValue;
    }
  }
  writeln("  Total Material Cost: $", totalMaterialCost);

  var totalInventoryCost = 0;
  for(var t in Time) {
    for(var i in Products) {
      totalInventoryCost += IC * inv[i][t].solutionValue;
    }
  }
  writeln("  Total Inventory Cost:  $", totalInventoryCost);
  
  var totalBackorderCost = 0;
  for(var t in Time) {
    for(var i in Products) {
      totalBackorderCost += PC[i] * back[i][t].solutionValue;
    }
  }
  writeln("  Total Backorder Cost:  $", totalBackorderCost);
  writeln("----------------------------------------------------------");
  writeln();


  // --- 3. Display Detailed Monthly Purchase Plan ---
  // This shows how much of each raw material to buy each month.
  writeln("Monthly Raw Material Purchase Plan (tons):");
  // Write header
  write("Month\t");
  for(var j in Materials) {
    write(j, "\t");
  }
  writeln();
  // Write data rows
  for(var t in Time) {
    write(t, "\t");
    for(var j in Materials) {
      write(buy[j][t].solutionValue, "\t");
    }
    writeln();
  }
  writeln();

  
  // --- 4. Display Detailed Monthly Production Plan ---
  // This shows the total production for each beam type each month.
  writeln("Monthly Beam Production Plan (tons):");
  // Write header
  write("Month\t");
  for(var i in Products) {
    write(i, "\t");
  }
  writeln();
  // Write data rows
  for(var t in Time) {
    write(t, "\t");
    for(var i in Products) {
      var totalSteel = steel[i]["New"][t].solutionValue + steel[i]["Recycled"][t].solutionValue;
      write(totalSteel, "\t");
    }
    writeln();
  }
  writeln();

  
  // --- 5. Display End-of-Month Inventory Levels ---
  // Shows how much inventory (if any) is held at the end of each month.
  writeln("End-of-Month Inventory (tons):");
  // Write header
  write("Month\t");
  for(var i in Products) {
    write(i, "\t");
  }
  writeln();
  // Write data rows
  for(var t in Time) {
    write(t, "\t");
    for(var i in Products) {
      write(inv[i][t].solutionValue, "\t");
    }
    writeln();
  }
  writeln();
  
  
  // --- 6. Display End-of-Month Backorder Levels ---
  // Shows how many backorders (if any) exist at the end of each month.
  writeln("End-of-Month Backorders (tons):");
  // Write header
  write("Month\t");
  for(var i in Products) {
    write(i, "\t");
  }
  writeln();
  // Write data rows
  for(var t in Time) {
    write(t, "\t");
    for(var i in Products) {
      write(back[i][t].solutionValue, "\t");
    }
    writeln();
  }
  writeln("----------------------------------------------------------");

}

CPLEX Code for the DATA file used for the model:
//----------------------------------------------------------------------
// Data for Steelco Problem
//----------------------------------------------------------------------

// ----- 1. SETS -----
Products = {"I", "W", "U", "H", "L"};
Materials = {"New", "Recycled"};
numMonths = 12;

// ----- 2. PARAMETERS -----

// Selling Price (from Table 1)
SP = [1000, 750, 1500, 1200, 800]; // Order: I, W, U, H, L

// Material Cost
MC = [600, 400]; // Order: New, Recycled

// Inventory Cost
IC = 40;

// Penalty Cost
PC = [100, 300, 250, 600, 1000]; // Order: I, W, U, H, L

// Purchase Limit
PL = [5000, 6000]; // Order: New, Recycled

// Material Yield
Yield = [1.0, 0.8]; // Order: New, Recycled

// Quality Requirement (Min % of New Steel)
QR = [0.40, 0.20, 0.60, 0.10, 0.25]; // Order: I, W, U, H, L

// Demand (from Table 2)
// Data must be [product][month]
DC = [
  // Jan,  Feb,  Mar,  Apr,  May,  Jun,  Jul,  Aug,  Sep,  Oct,  Nov,  Dec
  [3500, 1000,  700, 1400, 2000, 2000, 1000, 1700, 2000, 3000, 1000,  700], // "I"
  [2400,  300,  900,  800, 1400,  900,  900, 1000, 1700, 1500, 1900, 2000], // "W"
  [2700, 2400, 3100, 1600, 3600, 3700, 2000, 3100, 3300, 3000, 2000, 3100], // "U"
  [2500, 1300,  500, 3300, 2100, 1500, 1000,  800, 4100, 2000, 2800,  100], // "H"
  [1200, 1500, 4300, 3900,  800,  200, 3500, 1200, 2200, 1300, 4100, 1000]  // "L"
];

